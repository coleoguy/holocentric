max.taxa = 100,
include.extinct = F)[[1]]
tree$edge.length <- tree$edge.length / max(branching.times(tree))
# we then simulate the continious character
cont.trait <- sim.char(tree, 0.2, model = 'BM')[,,1]
# identifying which branch had a mean cont trait value in the upper and lower quartiles
# we do this by 1st doing an ASR for the continious trait
cont.trait.AC <- anc.ML(tree, cont.trait, model = "BM")
# this will hold all of the branch means in the same order they are given in tree
branch.means <- c()
# branch names is essentially paste(rootward node, tipward node)
branch.names <- c()
# then for each branch we go through and calculate the name and mean
for(j in 1:nrow(tree$edge)){
# we first find the cont trait value at the rootward node
node.o.int <- tree$edge[j,1]
# we have to look in two different places for cont trait values, either in the cont.trait vector
# (if the node is a tip) or in the ASR if it is an interior node
if(node.o.int <= 100){
one <- cont.trait[node.o.int]
}else{
one <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# we do the same for the tipward node
node.o.int <- tree$edge[j,2]
if(node.o.int <= 100){
two <- cont.trait[node.o.int]
}else{
two <- cont.trait.AC$ace[names(cont.trait.AC$ace) == as.character(node.o.int)]
}
# to find the mean we avg the rootward and the tipward cont trait values
branch.means <- c(branch.means, mean(one, two))
# we create branch names by pasting the rootwward and tipward node labels together
branch.names <- c(branch.names, paste(as.character(tree$edge[j,1]),as.character(tree$edge[j,2])))
}
# we name the branch names for nice bookkeeping
names(branch.means) <- branch.names
# finding upper and lower quartiles
upper <- summary(branch.means)[[5]]
lower <- summary(branch.means)[[2]]
scale.factor <- 5
# we leave the original tree un altered
alt.tree <- tree
# we then manipulate the branch lengths of those branches whose cont trait means are in the upper or lower quartiles
for(j in 1:length(branch.means)){
if(branch.means[j] < lower){alt.tree$edge.length[j] <- alt.tree$edge.length[j] / scale.factor}
if(branch.means[j] > upper){alt.tree$edge.length[j] <- alt.tree$edge.length[j] * scale.factor}
}
# next we simulated a discrete trait on this altered tree
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
rate <- .3
while(good.sim == F){
disc.trait <- sim.char(phy = alt.tree,
par = matrix(c(-rate, rate, rate, -rate), 2),
model = 'discrete',
root = sample(c(1,2),1))
if((0.05 * 100) < sum(disc.trait == min(disc.trait)) &&
sum(disc.trait == min(disc.trait)) < (.95 * 100)){
good.sim <- T
}
}
# we now apply the AncCond test to our simulated data and record its result
data <- data.frame(alt.tree$tip.label, cont.trait, disc.trait)
mc <- 1000
drop.state <- NULL
mat <- c(0,2,1,0)
pi <- 'estimated'
n.tails <- 1
message <- T
rm(list=ls()[-c(21,6,13,8,12,18,15,14)])
##### testing inputs #####
if(class(tree) != 'phylo') {stop('tree must be class phylo')}
if(!is.data.frame(data) & ncol(data) == 3){stop('data should be a dataframe with 3 columns\n(tip labels, cont data, discrete data)')}
if(class(mc) != 'numeric' | round(mc) != mc | mc < 1){stop('mc should be a numeric positive integer integer')}
if(!is.null(drop.state)) if(!drop.state %in% c(1,2)){stop('drop.state must be NULL, or numeric 1 or 2')}
if(!sum(mat == c(0,0,1,0)) == 4 & !sum(mat == c(0,1,1,0)) == 4 & !sum(mat == c(0,2,1,0)) == 4){
stop('mat must be a vector of the form c(0,0,1,0), c(0,1,1,0), or c(0,2,1,0)')
}
if((!pi %in% c('equal', 'estimated'))[1]){
if(!is.numeric(pi)) stop('pi must be equal, estimated or a vector of length 2\nwith probabilities for the state of the discrete character at the root')
if(length(pi) != 2 | sum(pi) != 1) stop('pi must be equal, estimated or a vector of length 2\nwith probabilities for the state of the discrete character at the root')
}
if(n.tails != 1 & n.tails != 2){stop('n.tails should be numeric 1 or 2')}
##### create named vector for disc trait for all taxa #####
dt.vec <- data[, 3]
names(dt.vec) <- data[, 1]
dt.vec
lkmod <- make.mk2(tree=tree, states=dt.vec)
dt.vec
tree
lkmod <- make.mk2(tree=tree, states=dt.vec-1)
argnames(lkmod)
fit <- mcmc(lkmod,x.init=runif(2,0,1), iter=10000)
fit <- mcmc(lkmod,x.init=runif(2,0,1), nsteps=10000)
fit <- mcmc(lkmod,x.init=runif(2,0,1), w=1,nsteps=10000)
max(branching.times(tree))
fit <- mcmc(lkmod,x.init=runif(2,0,1), w=.1,nsteps=10000)
fit <- mcmc(lkmod,x.init=runif(2,0,1), w=.1,nsteps=10000,prior=make.prior.exponential(1))
help("sim.char")
males = 100
females = 20
s = .3,
iter = 50000
s = .3
iter = 50000
gens = 1000
cores = 14
iter = 50
gens = 100
cores = 14
resultA <- c()
makeGenomes <- function(females, males, freqs=NULL){
population <- rep(0, 8)
if(!is.null(freqs)){
population <- freqs
}else{
print("supply frequencies")
}
names(population) <- c("fem.X1X1", "fem.X1X2", "fem.X2X1", "fem.X2X2",
"mal.X1Y1", "mal.X1Y2", "mal.X2Y1", "mal.X2Y2")
return(population)
}
measureFit <- function(h, s){
# mutation is deleterious in females
fit <- c(1,   1-h*s, 1-h*s,   1-s,
1,   1,     1,       1)
fit <- c(1,   1+h*s,         1+h*s,           1+s,
1,   1-h*s,         1-h*s,           1-s)
return(fit)
}
GetParentsGeno <- function(pop, fit, females, males){
# this effectively performs viability selection
# so we sample females as moms based on fitness
mom.genomes <- sample(x = 1:4,
size = females,
replace = T,
prob=pop[1:4]*fit[1:4])
dad.genomes <- sample(5:8,
size = males,
replace = T,
prob=pop[5:8]*fit[5:8])
mom.geno <- rep(0, 4)
names(mom.geno) <- c("X1X1", "X1X2", "X2X1", "X2X2")
mom.geno[1] <- sum(mom.genomes==1)
mom.geno[2] <- sum(mom.genomes==2)
mom.geno[3] <- sum(mom.genomes==3)
mom.geno[4] <- sum(mom.genomes==4)
dad.geno <- rep(0, 4)
names(dad.geno) <- c("X1Y1", "X1Y2", "X2Y1", "X2Y2")
dad.geno[1] <- sum(dad.genomes==5)
dad.geno[2] <- sum(dad.genomes==6)
dad.geno[3] <- sum(dad.genomes==7)
dad.geno[4] <- sum(dad.genomes==8)
parents <- list(mom.geno, dad.geno)
names(parents) <- c("moms", "dads")
return(parents)
}
makeEggs <- function(mom.geno){
eggs <- rep(0, 2)
names(eggs) <- c("X1", "X2")
eggs[1] <- mom.geno[1] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
eggs[2] <- mom.geno[4] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
return(eggs)
}
makeSperm <- function(dad.geno, rd){
sperm <- rep(0, 4)
names(sperm) <- c("X1", "X2", "Y1", "Y2")
sperm[1] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
sperm[2] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[3] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[4] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
return(sperm)
}
makeNewPop <- function(pop, eggs, sperm, females, males){
x  <-  paste(sample(1:2, size = females, replace=T, prob = eggs),
sample(1:2, size = females, replace=T, prob = sperm[1:2]))
pop[1] <- sum(x == "1 1")
pop[2] <- sum(x == "1 2")
pop[3] <- sum(x == "2 1")
pop[4] <- sum(x == "2 2")
x <- paste(sample(1:2, size = males, replace=T, prob = eggs),
sample(1:2, size = males, replace=T, prob = sperm[3:4]))
pop[5] <- sum(x == "1 1")
pop[6] <- sum(x == "1 2")
pop[7] <- sum(x == "2 1")
pop[8] <- sum(x == "2 2")
return(pop)
}
GetFreq <- function(pop, chrom, allele, males, females){
ones <- twos <- 0
if(chrom == "Y"){
if(allele == 1) ones <- (pop[5] + pop[7]) / males
if(allele == 2) twos <- (pop[6] + pop[8]) / males
}
if(chrom == "A"){
ones <- (pop[1]*2 + pop[2] + pop[3] +
pop[5]*2 + pop[6] + pop[7]) / (2 * sum(pop))
twos <- 1 - ones
}
if(chrom == "X"){
if(allele == 1){
ones <- (pop[1] * 2 + pop[2] + pop[3] + pop[5] + pop[6]) /
(males + females * 2)
}
if(allele == 2){
twos <- (pop[4] * 2 + pop[2] + pop[3] + pop[7] + pop[8]) /
(males + females * 2)
}
}
if(allele == 1) return(ones)
if(allele == 2) return(twos)
}
Generation <- function(pop, females, males, rd, h, s){
fit <- measureFit(h, s)
parents <- GetParentsGeno(pop, fit, females, males)
eggs <- makeEggs(parents$moms)
sperm <- makeSperm(parents$dads, rd)
pop <- makeNewPop(pop, eggs, sperm, females, males)
muts <- sum(rbinom(2*sum(pop), 1, .001))
if(muts > 0){
z <- which(pop > 0)
z <- z[!z %in% c(4, 8)]
mut.possible <- c()
# possible genotypes to mutate
if(length(z)>0){
for(q in z){
mut.possible <- c(rep(q, pop[q]), mut.possible)
}
# check to make sure it isnt already fixed
# draw genotypes to mutate
hits <- sample(mut.possible, muts, replace=T) # DID THIS FIX IT
# remove ind from old genotype
pop[1] <- pop[1] - sum(hits==1)
pop[2] <- pop[2] - sum(hits==2)
pop[3] <- pop[3] - sum(hits==3)
pop[5] <- pop[5] - sum(hits==5)
pop[6] <- pop[6] - sum(hits==6)
pop[7] <- pop[7] - sum(hits==7)
# add to new genotypes
pop[2] <- pop[2] + sum(hits==1)
pop[4] <- pop[4] + sum(hits%in%c(2,3))
pop[6] <- pop[6] + sum(hits==5)
pop[8] <- pop[8] + sum(hits%in%c(6,7))
}
}
#if(min(pop)<0) print("AHHH")
pop[pop<0]<-0
return(pop)
}
pop <- makeGenomes(females = females,
males = males,
freqs = c(c(females, 0, 0, 0),
c(males, 0, 0, 0)))
pop
resultA[k] <- GetFreq(pop, chrom = "A", allele = 2,
females = females, males = males)
k <- 1
resultA[k] <- GetFreq(pop, chrom = "A", allele = 2,
females = females, males = males)
resultA
pop <- Generation(pop, females = females, males = males,
rd = .5, h = .5, s = s)
pop
pop <- Generation(pop, females = females, males = males,
rd = .5, h = .5, s = s)
pop
for(k in 1:gens){
resultA[k] <- GetFreq(pop, chrom = "A", allele = 2,
females = females, males = males)
pop <- Generation(pop, females = females, males = males,
rd = .5, h = .5, s = s)
}
resultA
resultA <- c()
pop <- makeGenomes(females = females,
males = males,
freqs = c(c(females, 0, 0, 0),
c(males, 0, 0, 0)))
for(k in 1:gens){
resultA[k] <- GetFreq(pop, chrom = "A", allele = 2,
females = females, males = males)
pop <- Generation(pop, females = females, males = males,
rd = .5, h = .5, s = .0001)
}
resultA
registerDoMC(14)
# fate of sex limited deleterious mutations
# common sex: 50, 100, 500, 1000
# OSR: 0.2, 0.1
# s: 0.01, 0.05, 0.1
library(doMC)
registerDoMC(14)
x <- foreach(n=1:iter, .combine = "rbind") %dopar%{
resultA <- c()
pop <- makeGenomes(females = females,
males = males,
freqs = c(c(females, 0, 0, 0),
c(males, 0, 0, 0)))
for(k in 1:gens){
resultA[k] <- GetFreq(pop, chrom = "A", allele = 2,
females = females, males = males)
pop <- Generation(pop, females = females, males = males,
rd = .5, h = .5, s = s)
}
# this puts the final result of our sim together
resultA
}
View(x)
h <- .5
rd <- .5
measureFit <- function(h, s){
# mutation is deleterious in females
fit <- c(1,   1-h*s, 1-h*s,   1-s,
1,   1,     1,       1)
return(fit)
}
fit <- measureFit(h, s)
fit
pop
parents <- GetParentsGeno(pop, fit, females, males)
parents
pop
pop[4] <- 10
pop[1] <- 10
pop
parents <- GetParentsGeno(pop, fit, females, males)
parents
eggs <- makeEggs(parents$moms)
sperm <- makeSperm(parents$dads, rd)
eggs
sperm
pop
pop <- makeNewPop(pop, eggs, sperm, females, males)
pop
sum(pop)
2*sum(pop)
rbinom(2*sum(pop), 1, .001)
sum(rbinom(2*sum(pop), 1, .001))
muts <- 1
which(pop > 0)
z <- which(pop > 0)
z[!z %in% c(4, 8)]
pop
setwd("~/Desktop/Dropbox/gitrepos/holocentric/scripts")
# load packages
library(ape) # basic phylo tools
library(chromePlus) # chromosome models
library(diversitree) # basic likelihood functions
library(doMC) # this allows multicore runs on a mac
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("../data/misof.backbone.nex")
dat <- read.csv("../data/data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 50
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
# read in the data and the tree
trees <- read.nexus("../data/rainford.backbone.nex")
dat <- read.csv("../data/data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 50
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getData(trees, dat)
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
ncol(chroms)
rm(foo)
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# we will do this next bit twice to get w with and without polyploidy
# first with polyploidy
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
prior <- make.prior.exponential(.5)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
prior <- make.prior.exponential(1)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 20,
lower = 0)
prior <- make.prior.exponential(2)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 20,
lower = 0)
prior <- make.prior.exponential(2)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
# now with polyploidy
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
prior <- make.prior.exponential(.5)
temp.wp <- mcmc(con.lk.mk,
x.init = runif(8, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
temp.wp <- temp.wp[-c(1:10), ]
w.wp <- diff(sapply(temp.wp[2:9],
quantile, c(.05, .95)))
#################################
#                               #
#  Now we can do our full run   #
#                               #
#################################
#iter <- 1 # just for testing
# this will allow us to run on 14 cores
registerDoMC(14)
result <- list()
# we will loop through all 100 trees
# fitting model with polyploidy
result <- list()
# we will loop through all 100 trees
x <- foreach(i=1:100) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getData(trees, dat)
ncol(foo[[2]])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
# make the basic likelihood function for the data
lk.mk <- make.mkn(trees.pruned[[i]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# now we constrain our model to be biologically realistic for
# chromosomes.
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
# now we are ready to run our inference run
result[[i]] <- mcmc(con.lk.mk,
x.init =  runif(8, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
# just in case we have a crash lets write results for each tree
#write.csv(result[[i]], file=paste("/results/tree.p",i,".csv", sep=""))
}
foo <- x
results <- list()
depths <- getData(trees, dat)[[3]]
x[[i]][,2:9]
i <- 1
x[[i]][,2:9]
results <- list()
depths <- getData(trees, dat)[[3]]
for(i in 1:100){
#scaler <- max(branching.times(trees.pruned[[i]]))
x[[i]][,2:9] <- x[[i]][,2:9]/depths[i]
results[[i]] <- x[[i]]
}
save(results, file="rates.centromeres.wp.second.backbone")
load("~/Desktop/Dropbox/gitrepos/holocentric/results/cent.rates.RData")
