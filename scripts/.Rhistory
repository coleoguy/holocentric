# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
}
for(i in 7:length(orders)){
foo <- getDataOrder(trees, dat, order = orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# we will do this next bit twice to get w with and without polyploidy
# first with polyploidy
con.lk.mk.wop<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
con.lk.mk.wp<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
prior <- make.prior.exponential(.5)
temp.wop <- mcmc(con.lk.mk.wop,
x.init = runif(2, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wp <- mcmc(con.lk.mk.wp,
x.init = runif(3, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wop <- temp.wop[-c(1:10), ]
temp.wp <- temp.wp[-c(1:10), ]
w.wop <- diff(sapply(temp.wop[2:3],
quantile, c(.05, .95)))
w.wp <- diff(sapply(temp.wp[2:4],
quantile, c(.05, .95)))
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
}
for(i in 7:length(orders)){
foo <- getDataOrder(trees, dat, order = orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# we will do this next bit twice to get w with and without polyploidy
# first with polyploidy
con.lk.mk.wop<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
con.lk.mk.wp<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
prior <- make.prior.exponential(.5)
temp.wop <- mcmc(con.lk.mk.wop,
x.init = runif(2, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wp <- mcmc(con.lk.mk.wp,
x.init = runif(3, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wop <- temp.wop[-c(1:10), ]
temp.wp <- temp.wp[-c(1:10), ]
w.wop <- diff(sapply(temp.wop[2:3],
quantile, c(.05, .95)))
w.wp <- diff(sapply(temp.wp[2:4],
quantile, c(.05, .95)))
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
}
orders[i]
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
orders[8]
for(i in 8:length(orders)){
foo <- getDataOrder(trees, dat, order = orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# we will do this next bit twice to get w with and without polyploidy
# first with polyploidy
con.lk.mk.wop<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
con.lk.mk.wp<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
prior <- make.prior.exponential(.5)
temp.wop <- mcmc(con.lk.mk.wop,
x.init = runif(2, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wp <- mcmc(con.lk.mk.wp,
x.init = runif(3, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wop <- temp.wop[-c(1:10), ]
temp.wp <- temp.wp[-c(1:10), ]
w.wop <- diff(sapply(temp.wop[2:3],
quantile, c(.05, .95)))
w.wp <- diff(sapply(temp.wp[2:4],
quantile, c(.05, .95)))
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
# this within csv write was done when troubleshooting probably
# overkill at this point though.
# write.csv(cur.res, file=paste("../results/tree.nop.",
#                                   orders[i],
#                                   ".", j,".csv",
#                                   sep=""))
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
}
load("~/Desktop/Dropbox/gitrepos/holocentric/results/rates.Coleoptera.wop.rda")
foo <- x[[1]]
View(foo)
plot(foo$p, type="l")
for(i in 1:100){
foo <- x[[i]]
if(i == 1){
plot(foo$p, type="l")
}else{
lines(foo$p, col=rainbow(100)[i])
}
}
for(i in 1:100){
foo <- x[[i]]
if(i == 1){
plot(foo$p, type="l", c(-420,-390))
}else{
lines(foo$p, col=rainbow(100)[i])
}
}
for(i in 1:100){
foo <- x[[i]]
if(i == 1){
plot(foo$p, type="l", ylim=c(-420,-390))
}else{
lines(foo$p, col=rainbow(100)[i])
}
}
for(i in 1:100){
foo <- x[[i]]
if(i == 1){
plot(foo$p, type="l", ylim=c(-450,-390))
}else{
lines(foo$p, col=rainbow(100)[i])
}
}
for(i in 1:100){
foo <- x[[i]]
if(i == 1){
plot(foo$p, type="l", ylim=c(-450,-390), lwd=.5)
}else{
lines(foo$p, col=rainbow(100)[i], lwd=.5)
}
}
results <- matrix(NA, 2500, 4)
colnames(x[[1]])
results <- matrix(NA, 2500, 4)
colnames(results) <- colnames(x[[1]])
results <- matrix(NA, 0, 4)
colnames(results) <- colnames(x[[1]])
for(i in 1:100){
results <- rbind(results, x[[i]][26:50,])
}
View(results)
plot(density(results$asc1))
lines(density(results$desc1))
plot(density(results$asc1),xlim=c(0,.08),ylim=c(0,50))
lines(density(results$desc1))
plot(density(results$asc1),xlim=c(0,.08),ylim=c(0,55))
lines(density(results$desc1))
plot(results$asc1,type="l")
seq(from=1, to=2475, length.out=100)
seq(from=1, to=2476, length.out=100)
for(i in seq(from=1, to=2476, length.out=100)){
abline(v=i, col="red")
}
