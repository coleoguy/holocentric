#
# if(sum(mat) > 1){
#   # for the general model we partition the producing nodes for 1->2 and 1<-2 transitions
#   producing.nodes12 <- c()
#   producing.nodes21 <-c()
#   trans.maps <- current.map$maps[ss_nodes == T]
#   # now we take the rootward node of each branch and get rid of duplicates
#   wanted_nodes <- gsub(",.*", "", wanted_nodes)
#   ##### Just realized we can do this with describe.simmap :(
#   ##### But i dont want to change it, it would require match function
#   for(i in 1:length(wanted_nodes)){
#     if(names(trans.maps[[i]])[1] == '1'){
#       producing.nodes12 <- c(producing.nodes12, wanted_nodes[i])
#     }else if(names(trans.maps[[i]])[1] == '2'){
#       producing.nodes21 <- c(producing.nodes21, wanted_nodes[i])
#     }
#   }
#
#   producing.nodes12 <- unique(producing.nodes12)
#   producing.nodes21 <- unique(producing.nodes21)
#
#
#   ##### get estimated ancestral conditions ######
#   observed.anc.cond[[j]] <- list('12' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes12],
#                                  '21' = anc.states.cont.trait$ace[names(anc.states.cont.trait$ace) %in%
#                                                                     producing.nodes21])
########
}
iter = 10
j <- 1
current.map = anc.state.dt[[j]]
# if(sum(mat) > 1){
nulldist <- matrix(NA,iter,2)
colnames(nulldist) <- c('12','21')
n <- 1
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
null.disc.trait <- sim.char(phy = tree,
par = anc.state.dt$Q,
model = 'discrete',
root = sample(c(1,2),1))
anc.state.dt$Q
current.map$Q
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
null.disc.trait
unique(null.disc.trait)
length(unique(null.disc.trait))>1
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
rownames(null.disc.trait)
names(null.disc.trait)
help(make.simmap)
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
model = current.map$Q,
nsim = 1,
pi = pi,
message = F)
current.map$Q
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
plot(sim.anc.state.dt)
# if(sum(mat) > 1){
nulldist <- list()
n <- 1
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
nulldist[[1]]
# }else{
#   nulldist <- vector(length = iter)
# }
for(n in 1:iter){
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree, null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
}
CreateNull <- function(tree,                     # a tree type phylo
iter,                     # number of simulations for null
current.map,             # for Q-matrix
anc.states.cont.trait){   # ancestral state reconstruction for continuous
# if(sum(mat) > 1){
nulldist <- list()
# }else{
#   nulldist <- vector(length = iter)
# }
for(n in 1:iter){
# while loop is set up to make sure sufficient transitions occur on the tree
good.sim <- F
while(good.sim == F){
null.disc.trait <- sim.char(phy = tree,
par = current.map$Q,
model = 'discrete',
root = sample(c(1,2),1))[,,1]
if(length(unique(null.disc.trait))>1) good.sim <- T
}
# nullnames <- names(null.disc.trait)
# null.disc.trait <- as.factor(null.disc.trait)
# names(null.disc.trait) <- nullnames
sim.anc.state.dt <- make.simmap(tree = tree,
null.disc.trait,
Q = current.map$Q,
nsim = 1,
pi = pi,
message = F)
nulldist[[n]] <- exctractAncestral(current.map = sim.anc.state.dt,
anc.states.cont.trait = anc.states.cont.trait)
}
return(nulldist)
}
source('~/Desktop/Dropbox/projects/ancCond/analyses/functions.R')
source('~/Desktop/Dropbox/projects/ancCond/analyses/functions.R')
hist(density(rexp(n=1000, rate=.5)))
rexp(n=1000, rate=.5)
plot(density(rexp(n=1000, rate=.5)))
plot(density(rexp(n=10000, rate=.5)))
plot(density(rexp(n=100000, rate=.5)))
plot(density(rexp(n=100000, rate=.15)))
plot(density(rexp(n=100000, rate=1)))
plot(density(rexp(n=100000, rate=2)))
library(diversitree)
help("make.mkn")
citation
citation()
# load packages
library(ape) # basic phylo tools
library(chromePlus) # chromosome models
library(diversitree) # basic likelihood functions
library(doMC) # this allows multicore runs on a mac
registerDoMC(14)
iter <- 50
iter<-1
# for troubleshooting we might run on just a couple of trees
# usually ntree should be set equal to the number of trees being
# analyzed.
ntree <- 100
ntree<-2
# load custom functions
source("functions.R")
setwd("~/Desktop/Dropbox/gitrepos/holocentric/scripts")
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("../data/misof.backbone.nex")
dat <- read.csv("../data/data.invert.csv", as.is = T)[, -c(6:9)]
# lets find our orders first
foo <- getData(trees, dat)
tree <- foo[[1]]
genera <- row.names(foo[[2]])
orders <- dat$Order[dat$Genus %in% genera]
orders <- as.data.frame(table(orders))
# here I am reducing down to only estimate rates in orders
# with at least 20 species
orders <- as.character(orders$orders[orders$Freq>=20])
load("~/Desktop/Dropbox/gitrepos/holocentric/results/order.rates.RData")
for(i in 1:length(orders)){
foo <- getDataOrder(trees, dat, order = orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# we will do this next bit twice to get w with and without polyploidy
# first with polyploidy
con.lk.mk.wop<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
con.lk.mk.wp<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
prior <- make.prior.exponential(.5)
temp.wop <- mcmc(con.lk.mk.wop,
x.init = runif(2, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wp <- mcmc(con.lk.mk.wp,
x.init = runif(3, 0, 1),
prior = prior,
w = 1,
nsteps = 40,
upper = 50,
lower = 0)
temp.wop <- temp.wop[-c(1:10), ]
temp.wp <- temp.wp[-c(1:10), ]
w.wop <- diff(sapply(temp.wop[2:3],
quantile, c(.05, .95)))
w.wp <- diff(sapply(temp.wp[2:4],
quantile, c(.05, .95)))
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(2, 0, 1),
prior = prior,
w = w.wop,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:3] <- x[[k]][,2:3]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wop.rda", sep=""))
#### NOW WE RUN WITH POLYPLOIDY
x <- foreach(j=1:ntree) %dopar%{
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getDataOrder(trees, dat, order=orders[i])
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rm(foo)
lk.mk <- make.mkn(trees.pruned[[j]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = F,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = F))
cur.res <- mcmc(con.lk.mk,
x.init =  runif(3, 0, 1),
prior = prior,
w = w.wp,
nsteps = iter,
upper = 50,
lower = 0)
cur.res
}
scaler <- getDataOrder(trees, dat, order=orders[i])[[3]]
for(k in 1:ntree){
x[[k]][,2:4] <- x[[k]][,2:4]/scaler[k]
}
save(x, file=paste("../results/rates.", orders[i], ".wp.rda", sep=""))
}
library(ggplot2)
library(tidybayes)
load(file="../results/order.rates.RData")
# get parameter names correct
foo <- as.character(results.wop$type)
foo[foo=="asc"] <- "fission"
foo[foo=="desc"] <- "fusion"
results.wop$type <- as.factor(foo)
foo <- as.character(results.wp$type)
foo[foo=="asc"] <- "fission"
foo[foo=="pol"] <- "polyploidy"
foo[foo=="desc"] <- "fusion"
results.wp$type <- as.factor(foo)
# lets figure out the order for the data
foo <- aggregate(x = results.wp$rate,
by = list(results.wp$order, results.wp$type),
FUN = mean)
foo <- foo[foo$Group.2=="fission",]
foo <- foo[order(foo$x, decreasing=T),]
x <- row.names(foo)[which(foo$Group.1 %in% c("Hemiptera","Lepidoptera","Odonata"))]
x <- c(x, row.names(foo)[which(!foo$Group.1 %in% c("Hemiptera","Lepidoptera","Odonata"))])
x <- as.numeric(x)
# reorder so taxa are in right order
results.wop$order <- factor(results.wop$order,
levels(results.wop$order)[x])
results.wp$order <- factor(results.wp$order,
levels(results.wp$order)[x])
# this code is for single legend
ggplot(results.wop, aes(x=type, y=rate, color=order)) +
geom_jitter(cex=2, alpha=1,position=position_jitterdodge(.3)) +
theme_bw()+
guides(color=guide_legend(title="Order"))
# this code is for plot wo polyploidy
ggplot(results.wop, aes(x = type, y = rate, color = order)) +
geom_jitter(cex = .5, alpha = .1,
position = position_jitterdodge(.3)) +
theme_bw() +
theme(legend.position = "none") +
xlab("Parameter") + ylab("Rate") +
stat_summary(aes(x = type, y = rate, fill = order),
fun.data = "mean_hdci", fun.args = list(mult=1),
size = 0.4, position = position_jitterdodge(0),
inherit.aes = FALSE) # exported 4x4
# this code is for plot w polyploidy
ggplot(results.wp, aes(x=type, y=rate, color=order)) +
geom_jitter(cex=.5, alpha=.1,position=position_jitterdodge(.3)) +
theme_bw()+
theme(legend.position = "none")+
xlab("Parameter") + ylab("Rate") +
stat_summary(aes(x=type, y=rate, fill=order), fun.data="mean_hdci", fun.args = list(mult=1),
size = 0.4, position = position_jitterdodge(0),
inherit.aes = FALSE) # exported 6x4
load("../results/cent.rates-backbone2.RData")
load("../results/results/cent.rates-backbone1.RData")
load("../results/cent.rates-backbone2.RData")
load("../results/cent.rates-backbone1.RData")
ratesb1 <- rates[,-1]
ratesb2 <- f.results
rm(f.results, rates)
plot(density(ratesb1$asc1))
lines(density(ratesb2$asc1), col="red")
par(mfcol=c(2,2))
plot(density(ratesb1$asc1 - ratesb1$asc2), ylim=c(0,120),
xlab=expression(paste(Delta, R[gamma])),
main="Fission")
lines(density(ratesb2$asc1 - ratesb2$asc2),col="red",
main="Fission")
abline(v=0,lty=2)
plot(density(ratesb1$desc1 - ratesb1$desc2), ylim=c(0,240),
xlab=expression(paste(Delta, R[delta])),
main="Fusion")
lines(density(ratesb2$desc1 - ratesb2$desc2),col="red")
abline(v=0,lty=2)
plot(density(ratesb1$pol1 - ratesb1$pol2), ylim=c(0,1520),
main="Polyploidy",
xlab=expression(paste(Delta, R[rho])))
lines(density(ratesb2$pol1 - ratesb2$pol2),col="red")
abline(v=0,lty=2)
# load packages
library(ape) # basic phylo tools
library(chromePlus) # chromosome models
library(diversitree) # basic likelihood functions
library(doMC) # this allows multicore runs on a mac
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("../data/rainford.backbone.nex")
dat <- read.csv("../data/data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 50
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getData(trees, dat)
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
ncol(chroms)
rm(foo)
lk.mk <- make.mkn(trees.pruned[[1]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
#we will do this next bit twice to get w with and without polyploidy
# first with out polyploidy
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
prior <- make.prior.exponential(2)
temp.wop <- mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = 1,
nsteps = 20,
upper = 50,
lower = 0)
temp.wop <- temp.wop[-c(1:10), ]
w.wop <- diff(sapply(temp.wop[2:7],
quantile, c(.05, .95)))
load("~/Desktop/Dropbox/gitrepos/holocentric/results/cent.rates.simple.model.RData")
par(mfcol=c(1,2))
load("../results/cent.rates-backbone1.RData")
library(coda)
fission <- rates$asc1-rates$asc2
fusion <- rates$desc1-rates$desc2
poly <- rates$pol1-rates$pol2
hpdfis <- HPDinterval(as.mcmc(fission))
hpdfus <- HPDinterval(as.mcmc(fusion))
hpdpol <- HPDinterval(as.mcmc(poly))
cols <- c(rgb(1, 0, 0, .5), rgb(0, 1, 0, .5), rgb(0, 0, 1, .5))
plot(0,0,col="white",
ylim=c(-50,700),
xlim=c(-.02,.01),
xlab=expression(paste(Delta, R[x])),
ylab="density")
abline(v=0, lty=3,col="black")
polygon(density(fission, bw = .0005), col = cols[1])
polygon(density(fusion, bw = .0005),col = cols[2])
polygon(density(poly, bw = .0005),col = cols[3])
points(pch = 22, bg = cols,
x = rep(-.02, 3), y = c(700, 650, 600))
text(x = rep(-.02, 3), y = c(700, 650, 600), pos = 4, cex = .7,
labels=c("fission", "fusion", "polyploidy"))
lines(y=rep(-15, 2), x=hpdfis, col=cols[1], lwd=4)
lines(y=rep(-37, 2), x=hpdfus, col=cols[2], lwd=4)
lines(y=rep(-59, 2), x=hpdpol, col=cols[3], lwd=4)
# export this as pdf at 8x4
ls()
list.files
list.files()
setwd("~/Desktop/Dropbox/gitrepos/holocentric/results")
list.files()
setwd("~/Desktop/Dropbox/gitrepos/holocentric/scripts")
par(mfcol=c(1,2))
load("../results/cent.rates-backbone1.RData")
library(coda)
fission <- rates$asc1-rates$asc2
fusion <- rates$desc1-rates$desc2
poly <- rates$pol1-rates$pol2
hpdfis <- HPDinterval(as.mcmc(fission))
hpdfus <- HPDinterval(as.mcmc(fusion))
hpdpol <- HPDinterval(as.mcmc(poly))
cols <- c(rgb(1, 0, 0, .5), rgb(0, 1, 0, .5), rgb(0, 0, 1, .5))
plot(0,0,col="white",
ylim=c(-50,700),
xlim=c(-.02,.01),
xlab=expression(paste(Delta, R[x])),
ylab="density")
abline(v=0, lty=3,col="black")
polygon(density(fission, bw = .0005), col = cols[1])
polygon(density(fusion, bw = .0005),col = cols[2])
polygon(density(poly, bw = .0005),col = cols[3])
points(pch = 22, bg = cols,
x = rep(-.02, 3), y = c(700, 650, 600))
text(x = rep(-.02, 3), y = c(700, 650, 600), pos = 4, cex = .7,
labels=c("fission", "fusion", "polyploidy"))
lines(y=rep(-15, 2), x=hpdfis, col=cols[1], lwd=4)
lines(y=rep(-37, 2), x=hpdfus, col=cols[2], lwd=4)
lines(y=rep(-59, 2), x=hpdpol, col=cols[3], lwd=4)
load("../results/cent.rates.simple.model.RData")
#rates must be back transformed into units of
# millions of years tree depth is 479.1039
rates[,2:7] <- rates[,2:7]/479.1039
library(coda)
fission <- rates$asc1-rates$asc2
fusion <- rates$desc1-rates$desc2
hpdfis <- HPDinterval(as.mcmc(fission))
hpdfus <- HPDinterval(as.mcmc(fusion))
cols <- c(rgb(1, 0, 0, .5), rgb(0, 1, 0, .5))
plot(0,0,col="white",
ylim=c(-5,75),
xlim=c(-.06,.1),
xlab=expression(paste(Delta, R[x])),
ylab="density")
abline(v=0, lty=3,col="black")
polygon(density(fission), col = cols[1])
polygon(density(fusion),col = cols[2])
lines(y=rep(-1.7, 2), x=hpdfis, col=cols[1], lwd=4)
lines(y=rep(-4, 2), x=hpdfus, col=cols[2], lwd=4)
# load packages
library(ape) # basic phylo tools
library(chromePlus) # chromosome models
library(diversitree) # basic likelihood functions
library(doMC) # this allows multicore runs on a mac
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("../data/misof.backbone.nex")
dat <- read.csv("../data/data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 50
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getData(trees, dat)
