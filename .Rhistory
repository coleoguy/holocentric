dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
table(good.genera)
table(good.genera)
which(dat$Genus == good.genera[1])
which(dat$Genus == good.genera[1])
sample(which(dat$Genus == good.genera[1]), 1)
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
View(dat.pruned)
i <- 2
good.genera[i]
which(dat$Genus == good.genera[i])
hit <- which(dat$Genus == good.genera[i])
length(hit>1)
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
View(dat.pruned)
table(dat.pruned$Genus)
sum(trees[[1]]$tip.label %in% dat.pruned$Genus)
trees[[1]]$tip.label %in% dat.pruned$Genus
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
foo <- drop.tip(trees[[1]], tip = missing)
plot(foo)
plot(foo, cex=.1)
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
trees.pruned[[i]] <- drop.tip(trees[[i]], tip = missing)
}
plot(trees.pruned, cex=.2)
plot(trees.pruned[[1]], cex=.2)
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haoloid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[chrom$haploid != "#VALUE!", ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haoloid.num,
dat.pruned$chromosome, stringsAsFactors = F)
View(chrom)
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
trees.pruned[[i]] <- drop.tip(trees[[i]], tip = missing)
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haoloid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
chroms <- datatoMatrix(chrom, range=range(chrom$haploid), hyper=T)
# set the MCMC chain length
iter <- 5
library(diversitree)
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees.pruned[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
trees.pruned[[1]]
chroms
rowSums(chrom)
rowSums(chroms)
rowSums(chroms)->foo
range(foo)
min(foo)
max(foo)
source("functions.R")
GetInitialPop <-function(pop.size){
sdr <- c("X","Y")
gamete <- c("S","E")
SA <- 0:1
structure <- c("N","P","U")
haplotypes <- c()
for(i in 1:2){
for(j in 1:2){
for(k in 1:2){
for(m in 1:3){
haplotypes <- c(haplotypes,
paste(sdr[i],
gamete[j],
SA[k],
structure[m],
sep = ""))
}
}
}
}
haplotypes <- haplotypes[-c(19:24)]
eggs.names <- haplotypes[7:12]
sperm.names <- haplotypes[c(1:6,13:18)]
eggs <- rep(0, 6)
names(eggs) <- eggs.names
sperm <- rep(0, 12)
names(sperm) <- sperm.names
pop <- expand.grid(eggs,sperm, stringsAsFactors = F)
pop$number <- rep(0, 72)
colnames(pop)[1:2] <- c("egg","sperm")
# this puts the max whole number of individuals into
# each starting category
eggs[3] <- floor(pop.size/4)
eggs[6] <- floor(pop.size/4)
sperm[3] <- floor(pop.size/8)
sperm[6] <- floor(pop.size/8)
sperm[9] <- floor(pop.size/8)
sperm[12] <- floor(pop.size/8)
# these are our leftovers
leftover <- pop.size%%4
if(leftover>0){
if(sample(c(T,F), 1)){
x <- sample(c(3,6), 1)
eggs[x] <- eggs[x] + leftover
}else{
x <- sample(c(3,6,9,12), 1)
sperm[x] <- sperm[x] + leftover
}
}
gametes <-c(eggs,sperm)
return(gametes)
}
#
# make a matrix
getAdults <- function(pop.gam){
pop.mat <- matrix(0,6,12)
colnames(pop.mat) <- names(pop.gam)[7:18]
rownames(pop.mat) <- names(pop.gam)[1:6]
# fix this so that you always maintain population size
frac.sperm <- pop.gam[7:18]/sum(pop.gam[7:18])
frac.eggs <- pop.gam[1:6]/sum(pop.gam[1:6])
extra <- 0
for(i in 1:ncol(pop.mat)){
for(j in 1:nrow(pop.mat)){
pop.mat[j, i] <- floor(sum(pop.gam) * frac.sperm[i] * frac.eggs[j])
pos.extra <- (sum(pop.gam) * frac.sperm[i] * frac.eggs[j]) -pop.mat[j, i]
if(pos.extra != 0){
extra <- extra + pos.extra
}
}
}
if(extra != 0){
hits <- sample(1:72, size=extra, replace=T, prob= as.vector(pop.mat))
vec <- as.vector(pop.mat)
for(i in 1:length(hits)){
vec[hits[i]] <- vec[hits[i]] + 1
}
temp.pop <- matrix(vec, 6, 12)
colnames(temp.pop) <- colnames(pop.mat)
row.names(temp.pop) <- row.names(pop.mat)
pop.mat <- temp.pop
}
return(pop.mat)
}
popFit <- function(pop.adu,s,h){
genotype.fit.mat  <- matrix(c(1+s,1,1+h*s,1+h*s,1,1+s),3,2, byrow = TRUE)
colnames(genotype.fit.mat) <- c("male", "female")
rownames(genotype.fit.mat) <- c("00","01","11")
pop.fit <- pop.adu
for(i in 1:nrow(pop.fit)){
for(j in 1:ncol(pop.fit)){
print(i)
print(j)
a1 <- (substr(x = colnames(pop.fit)[j], start=3, stop=3))
a2 <- (substr(x = rownames(pop.fit)[i], start=3, stop=3))
geno <- paste(sort(c(a1,a2), decreasing=F), collapse="")
# if (a1>=a2){
#   geno <- paste(a2,a1, sep = "")
# }else{
#   geno <- paste(a1,a2, sep = "")
# }
if(j > 6){
cur.fit.col <- 1
}else{
cur.fit.col <- 2
}
pop.fit[i, j] <- genotype.fit.mat[rownames(genotype.fit.mat) == geno, cur.fit.col]
}
return(pop.fit)
}
}
setwd("~/Desktop/Dropbox/projects/fusion-par/r.scripts")
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=555)
pop.adu <- getAdults(pop.gam)
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=555)
pop.adu <- getAdults(pop.gam)
s <- .1
h <- .5
genotype.fit.mat  <- matrix(c(1+s,1,1+h*s,1+h*s,1,1+s),3,2, byrow = TRUE)
View(genotype.fit.mat)
colnames(genotype.fit.mat) <- c("male", "female")
rownames(genotype.fit.mat) <- c("00","01","11")
View(genotype.fit.mat)
pop.fit <- pop.adu
j <- 1
colnames(pop.fit)[j]
substr(x = colnames(pop.fit)[j], start=3, stop=3)
View(genotype.fit.mat)
View(genotype.fit.mat)
pop.fit <- pop.adu
for(i in 1:nrow(pop.fit)){
print(i)
for(j in 1:ncol(pop.fit)){
print(j)
a1 <- (substr(x = colnames(pop.fit)[j], start=3, stop=3))
a2 <- (substr(x = rownames(pop.fit)[i], start=3, stop=3))
geno <- paste(sort(c(a1,a2), decreasing=F), collapse="")
# if (a1>=a2){
#   geno <- paste(a2,a1, sep = "")
# }else{
#   geno <- paste(a1,a2, sep = "")
# }
if(j > 6){
cur.fit.col <- 1
}else{
cur.fit.col <- 2
}
pop.fit[i, j] <- genotype.fit.mat[rownames(genotype.fit.mat) == geno, cur.fit.col]
}
return(pop.fit)
}
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=555)
pop.adu <- getAdults(pop.gam)
pop.fits <- popFit(pop.adu, s=.5, h=.5)
View(pop.fits)
View(pop.adu)
View(pop.fits)
unlist(pop.adu)
as.vector(pop.adu)
# Viability Selection
genos <- as.vector(pop.adu)
geno.fits <- as.vector(pop.fits)
genos
geno.fits
which(genos!=0)
geno.fits[which(genos!=0)]
sum(pop.adu)
sample(genos.present, prob=geno.fits[which(genos!=0),], size = (.9*sum(pop.adu)))
# Viability Selection
genos <- as.vector(pop.adu)
geno.fits <- as.vector(pop.fits)
genos.present <- which(genos!=0)
sample(genos.present, prob=geno.fits[which(genos!=0),], size = (.9*sum(pop.adu)))
sample(genos.present, prob=geno.fits[which(genos!=0)], size = (.9*sum(pop.adu)))
sample(genos.present, prob=geno.fits[which(genos!=0)], replace=T, size = (.9*sum(pop.adu)))
pop.adu <- pop.juv
View(pop.adu)
pop.adu <- 0
pop.adu <- pop.juv
pop.adu[,] <- 0
pop.adu <- pop.juv
pop.adu <- pop.juv
# model for autosome fusions to SSR vs PAR of sex chromosomes
# 15 October 2019
#### Why don't you try and take this code and turn it into a function called:
#### GetInitialPop()
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=555)
pop.juv <- getAdults(pop.gam)
# Get population fitnesses
pop.fits <- popFit(pop.juv, s=.5, h=.5)
# Viability Selection
genos <- as.vector(pop.juv)
geno.fits <- as.vector(pop.fits)
genos.present <- which(genos!=0)
survivors <- sample(genos.present,
prob=geno.fits[which(genos!=0)],
replace=T, size = (.9*sum(pop.juv)))
pop.adu <- pop.juv
pop.adu[,] <- 0
View(pop.adu)
as.vector(pop.juv)
genos.adu <- vector(length=72)
genos.adu <- rep(0, 72)
i <- 1
survivors[i]
genos.adu <- rep(0, 72)
for(i in 1:length(survivors)){
genos.adu[survivors[i]] <- genos.adu[survivors[i]] + 1
}
genos
genos.adu
pop.adu[,] <- genos.adu
View(pop.adu)
View(pop.juv)
# Initial Population
pop.gam <- GetInitialPop(pop.size=5000)
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=5000)
pop.juv <- getAdults(pop.gam)
# Get population fitnesses
pop.fits <- popFit(pop.juv, s=.95, h=.5)
# Viability Selection
genos <- as.vector(pop.juv)
geno.fits <- as.vector(pop.fits)
genos.present <- which(genos!=0)
survivors <- sample(genos.present,
prob=geno.fits[which(genos!=0)],
replace=T, size = (.9*sum(pop.juv)))
genos.adu <- rep(0, 72)
for(i in 1:length(survivors)){
genos.adu[survivors[i]] <- genos.adu[survivors[i]] + 1
}
pop.adu <- pop.juv
pop.adu[,] <- genos.adu
View(pop.juv)
View(pop.adu)
setwd("~/Desktop/Dropbox/gitrepos/holocentric")
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat$binom, dat$haoloid.num, dat$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("species", "haploid", "chrom")
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat$binom, dat$haoloid.num, dat$chromosome, stringsAsFactors = F)
# slim the data to include only the desired data
chrom <- data.frame(dat$binom, dat$haploid.num, dat$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("species", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[chrom$haploid != "#VALUE!", ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
trees.pruned[[i]] <- drop.tip(trees[[i]], tip = missing)
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haoloid.num,
dat.pruned$chromosome, stringsAsFactors = F)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
chroms <- datatoMatrix(chrom, range=range(chrom$haploid), hyper=T)
# set the MCMC chain length
iter <- 5
library(diversitree)
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees.pruned[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
help("constrainMkn")
### This sets up the model described in the paper
con.lk.mk<-constrainMkn(data=chroms, lik=lk.mk, hyper=T,
polyploidy=F, verbose=F,
constrain=list(drop.demi=T))
argnames(con.lk.mk)
temp <- mcmc(con.lk.mk, x.init=runif(6,0,8), w=1, nsteps=iter)
runif(8,0,10)
max(branching.times(trees.pruned[[1]]))
cur.tree <- drop.tip(trees[[i]], tip = missing)
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
cur.tree$edge.length <-  cur.tree$edge.length/ max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
chroms <- datatoMatrix(chrom, range=range(chrom$haploid), hyper=T)
# set the MCMC chain length
iter <- 5
library(diversitree)
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees.pruned[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
### This sets up the model described in the paper
con.lk.mk<-constrainMkn(data=chroms, lik=lk.mk, hyper=T,
polyploidy=F, verbose=F,
constrain=list(drop.demi=T))
argnames(con.lk.mk)
temp <- mcmc(con.lk.mk, x.init=runif(8,0,10), w=1, nsteps=iter)
w <- diff(sapply(temp[1:6], quantile, c(.05, .95)))
w
View(temp)
argnames(con.lk.mk)
temp <- mcmc(con.lk.mk, x.init=runif(8,0,10), w=1, nsteps=20)
temp[-c(1:5),]
w <- diff(sapply(temp[2:9], quantile, c(.05, .95)))
