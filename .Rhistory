x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=.5)
y <- y + rnorm(mean=.1*x2, sd=.1, n=1000)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.1*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
summary(lm1 <- lm(y ~ x1 + x2 + x3))
slm1 <- step(lm1)
summary(slm1)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
set.seed(1)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
set.seed(1)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
set.seed(2)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
set.seed(3)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- sample(0:1, 1000, replace=T) # noise
x4 <- sample(0:1, 1000, replace=T) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
slm1 <- step(lm1)
summary(slm1)
install.packages("ppcor")
library(ppcor)
help("spcor")
summary(lm(y~x1))
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
slm1 <- step(lm1)
summary(slm1)
summary(lm(y~x1))
summary(lm(y~x2))
summary(lm(y~x3))
summary(lm(y~x4))
summary(lm(y~x3))
set.seed(3)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- rnorm(mean=1, sd=.3, n=1000) # noise
x4 <- rnorm(mean=1, sd=.3, n=1000) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
plot(y~x3)
summary(lm1 <- lm(y ~ x1 + x2 + x3 + x4))
slm1 <- step(lm1)
summary(slm1)
summary(lm(y~x1))
summary(lm(y~x2))
summary(lm(y~x3))
summary(lm(y~x4))
summary(lm(y~x1))
AIC(lm(y~x1))
AIC(lm(y~x1))
AIC(lm(y~x1 + x2))
AIC(lm(y~x1 + x2 + x3))
AIC(lm(y~x1 + x2 + x3 + x4))
lm(y~x1)
fit1 <- lm(y~x1)
fit1
summary(fit1)
loglik(lm(y~x1))
logLik(lm(y~x1))
logLik(fit1)
logLik(fit2)
fit2 <- lm(y~x1 + x2)
fit3 <- lm(y~x1 + x2 + x3)
fit4 <- lm(y~x1 + x2 + x3 + x4)
logLik(fit1)
logLik(fit2)
logLik(fit3)
logLik(fit4)
source("functions.R")
setwd("~/Desktop/Dropbox/projects/fusion-par/r.scripts")
source("functions.R")
# Initial Population
pop.gam <- GetInitialPop(pop.size=5000)
pop.juv <- getAdults(pop.gam)
View(pop.juv)
# Get population fitnesses
pop.fits <- popFit(pop.juv, s=.95, h=.5)
View(pop.fits)
View(pop.fits)
# Viability Selection
genos <- as.vector(pop.juv)
geno.fits <- as.vector(pop.fits)
genos.present <- which(genos!=0)
survivors <- sample(genos.present,
prob=geno.fits[which(genos!=0)],
replace=T, size = (.9*sum(pop.juv)))
genos.adu <- rep(0, 72)
for(i in 1:length(survivors)){
genos.adu[survivors[i]] <- genos.adu[survivors[i]] + 1
}
pop.adu <- pop.juv
# this is what our next functino should retuern
pop.adu[,] <- genos.adu
View(pop.adu)
View(pop.juv)
set.seed(3)
x1 <- runif(n=1000, min=5, max=10) # main predictor
x2 <- rnorm(mean=1, sd=.3, n=1000) # secondary predictor
x3 <- rnorm(mean=1, sd=.3, n=1000) # noise
x4 <- rnorm(mean=1, sd=.3, n=1000) # noise
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
rnorm(mean=.5*x2, sd=.1, n=1000)
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1)
y <- y + rnorm(mean=.5*x2, sd=.1, n=1000)
# now lets make the response variable
y1 <- rnorm(mean=x1, n=1000, sd=1)
y2 <- y1 + rnorm(mean=.5*x2, sd=.1, n=1000)
hist(x1)
x1[1]
x1[2]
y <- rnorm(mean=x1, n=1000, sd=1)
plot(y~x)
plot(y~x1)
y <- rnorm(mean=x1, n=1000, sd=.1)
plot(y~x1)
y <- rnorm(mean=x1, n=1000, sd=1)
plot(y~x1)
hist(x2)
hist(x2/2)
hist(rnorm(mean=.5*x2, sd=.1, n=1000))
y <- rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x2)
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=1) + rnorm(mean=.5*x2, sd=.1, n=1000)
plot(y~x1)
plot(y~x2)
fit <- lm(y ~x1)
plot(fit$residuals~x2)
summary(lm(fit$residuals~x2))
# now lets make the response variable
y <- rnorm(mean=x1, n=1000, sd=.01) + rnorm(mean=.5*x2, sd=.1, n=1000)
fit <- lm(y ~x1)
plot(fit$residuals~x2)
x <- c(11,11,16,15)
y <- c(5,7,9,7)
plot(y~x)
library(chromePlus)
help("datatoMatrix")
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
cur.tree$edge.length <-  cur.tree$edge.length/ max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
setwd("~/Desktop/Dropbox/gitrepos/holocentric")
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
cur.tree$edge.length <-  cur.tree$edge.length/ max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
View(chrom)
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
cur.tree$edge.length <-  cur.tree$edge.length/ max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
View(chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
197:207
sample(2:88, 11)
chrom$haploid[197:207]<- sample(2:88, 11)
View(chrom)
83:100
chrom$haploid[83:100]<- sample(2:88, 18)
chroms <- datatoMatrix(chrom, range=range(chrom$haploid), hyper=T)
# set the MCMC chain length
iter <- 20
library(diversitree)
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees.pruned[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
### This sets up the model described in the paper
con.lk.mk<-constrainMkn(data=chroms, lik=lk.mk, hyper=T,
polyploidy=F, verbose=F,
constrain=list(drop.demi=T, drop.poly=T))
argnames(con.lk.mk)
temp <- mcmc(con.lk.mk, x.init=runif(8,0,10), w=1, nsteps=iter)
temp <- mcmc(con.lk.mk, x.init=runif(6,0,10), w=1, nsteps=iter)
con.lk.mk
argnames(con.lk.mk)
con.lk.mk(pars=c(10,10,1,1,1,1))
con.lk.mk(pars=c(1,1,10,10,1,1))
con.lk.mk(pars=c(1,1,10,10,.01,01))
con.lk.mk(pars=c(1,1,100,100,.01,01))
con.lk.mk(pars=c(10,10,100,100,.01,01))
con.lk.mk(pars=c(2,2,100,100,.01,01))
con.lk.mk(pars=c(1,1,100,100,.01,01))
con.lk.mk(pars=c(10,10,1,1,.01,.01))
con.lk.mk(pars=c(1,1,10,10,.01,01))
View(chrom)
#create crazy high rate in monocentric
chrom$haploid[chrom$chrom==0]<- 10
chrom$haploid[chrom$chrom==1]<- sample(6:12, size=length(chrom$chrom==1),replace=T)
sample(6:12, size=length(chrom$chrom==1),replace=T)
# Heath pretending to be Michelle or Sarah
library(ape)
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is=T)[,-c(6:9)]
# TODO compare tree and data and get just the overlap
tree.genera <- trees[[1]]$tip.label
good.genera <- unique(dat$Genus[which(dat$Genus %in% tree.genera)])
hit <- sample(which(dat$Genus == good.genera[1]), 1)
dat.pruned <- dat[hit, ]
for(i in 2:length(good.genera)){
hit <- which(dat$Genus == good.genera[i])
if(length(hit)>1)  hit <- sample(hit, 1)
dat.pruned <- rbind(dat.pruned, dat[hit, ])
}
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% dat.pruned$Genus]
trees.pruned <- list()
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
cur.tree$edge.length <-  cur.tree$edge.length/ max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
library(chromePlus)
# slim the data to include only the desired data
chrom <- data.frame(dat.pruned$Genus,
dat.pruned$haploid.num,
dat.pruned$chromosome, stringsAsFactors = F)
colnames(chrom) <- c("genus", "haploid", "chrom")
chrom$chrom[chrom$chrom == "mono"] <- 0
chrom$chrom[chrom$chrom == "holo"] <- 1
chrom <- chrom[complete.cases(chrom), ]
chrom$haploid <- as.numeric(chrom$haploid)
chrom$chrom <- as.numeric(chrom$chrom)
### range should be larger than that observed in the
### data however it should be as small as possible without
### impacting inference to speed computation
# check the range of chromosome numbers present
range(chrom$haploid)
#create crazy high rate in monocentric
chrom$haploid[chrom$chrom==0]<- 10
chrom$haploid[chrom$chrom==1]<- sample(6:12, size=sum(chrom$chrom==1),replace=T)
View(chrom)
chroms <- datatoMatrix(chrom, range=range(chrom$haploid), hyper=T)
# set the MCMC chain length
iter <- 20
library(diversitree)
### w is best set by doing a short run and getting some idea of the
### confidence interval on these parameters
lk.mk <- make.mkn(trees.pruned[[1]], states=chroms, k=ncol(chroms), strict=F, control=list(method="ode"))
ncol(chroms)
### This sets up the model described in the paper
con.lk.mk<-constrainMkn(data=chroms, lik=lk.mk, hyper=T,
polyploidy=F, verbose=F,
constrain=list(drop.demi=T, drop.poly=T))
argnames(con.lk.mk)
temp <- mcmc(con.lk.mk, x.init=runif(6,0,10), w=1, nsteps=iter)
i<-1
temp[-c(1:5),]
w <- diff(sapply(temp[2:9], quantile, c(.05, .95)))
w <- diff(sapply(temp[2:7], quantile, c(.05, .95)))
# make the initial likelihood function
lk.mk <- make.mkn(trees.pruned[[i]], states = chroms, k = ncol(chroms),
strict = F, control = list(method = "ode"))
# constrain to a biologically realistic model of chrom evolution
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T))
# constrain to a biologically realistic model of chrom evolution
con.lk.mk<-constrainMkn(data = chroms, lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly=T))
argnames(con.lk.mk)
# run the MCMC
results[[i]] <- mcmc(con.lk.mk, x.init = colMeans(temp)[2:7],
w = w, nsteps = iter)
### this will cycle through all 100 trees
results <- list()
# run the MCMC
results[[i]] <- mcmc(con.lk.mk, x.init = colMeans(temp)[2:7],
w = w, nsteps = iter)
foo <- results[[1]]
View(temp)
hist(rexp(n=1000, rate=1))
setwd("~/Desktop/Dropbox/gitrepos/holocentric")
# load packages
library(ape)
library(chromePlus)
library(diversitree)
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 10
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
i <- 1
# slim the data to include only the desired data
# and generate the format table needed by chromPlus
foo <- getData(trees, dat)
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rate.scalers[i] <- foo[[3]][i]
rm(foo)
View(chroms)
View(chroms)
row.names(chroms) == trees.pruned[[1]]$tip.label
chroms2 <- chroms[row.names(chrom)==trees.pruned[[1]]$tip.label[1],]
chroms2 <- chroms[row.names(chroms)==trees.pruned[[1]]$tip.label[1],]
monocentric idea on a tree of insects
# load packages
library(ape)
library(chromePlus)
library(diversitree)
# load custom functions
source("functions.R")
# read in the data and the tree
trees <- read.nexus("misof.backbone.nex")
dat <- read.csv("data.invert.csv", as.is = T)[, -c(6:9)]
# set the MCMC chain length
iter <- 50
# we scale our trees so lets store that info for transforming
# rates back into millions of years
rate.scalers <- c()
foo <- getData(trees, dat)
trees.pruned <- foo[[1]]
chroms <- foo[[2]]
rate.scalers[i] <- foo[[3]][i]
rm(foo)
rownames(chroms)
chroms2 <- chroms
rownames(chroms2) <- 1:599
i <- 1
# make the basic likelihood function for the data
lk.mk <- make.mkn(trees.pruned[[i]], states = chroms,
k = ncol(chroms), strict = F,
control = list(method = "ode"))
# make the basic likelihood function for the data
lk.mk <- make.mkn(trees.pruned[[i]], states = chroms2,
k = ncol(chroms2), strict = F,
control = list(method = "ode"))
